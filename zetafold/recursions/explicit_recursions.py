##################################################################################################
# recursions.py          = user-editable, easier to read (but slower in Python) recursions. Edit this one!
#                           can force zetafold.py to use it with --simple.
#
# explicit_recursions.py = generated by create_explicit_recursions.py from recursions.py. This
#                           is the one used by default in zetafold.py due to speed.
##################################################################################################
def update_Z_cut( self, i, j ):
    '''
    Z_cut is the partition function for independently combining one contiguous/bonded segment emerging out of i to a cutpoint c, and another segment that goes from c+1 to j.
    Useful for Z_BP and Z_final calcs below.
    Analogous to 'exterior' Z in Mathews calc & Dirks multistrand calc.
    '''
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK

    (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
     sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
    offset = ( j - i ) % N
    for c in range( i, i+offset ):
        if not ligated[c%N]:
            # strand 1  (i --> c), strand 2  (c+1 -- > j)
            if c == i and (c+1)%N == j:                                 contribs.append( 1.0)
            if c == i and (c+1)%N != j and ligated[(j-1)%N]:                contribs.append( Z_linear.Q[(c+1)%N][(j-1)%N] )
            if c != i and (c+1)%N == j and ligated[i%N]:                  contribs.append( Z_linear.Q[(i+1)%N][c%N] )
            if c != i and (c+1)%N != j and ligated[i%N] and ligated[(j-1)%N]: contribs.append( Z_linear.Q[(i+1)%N][c%N] * Z_linear.Q[(c+1)%N][(j-1)%N] )

    Z_cut.Q[i%N][j%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
         sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
        offset = ( j - i ) % N
        for c in range( i, i+offset ):
            if not ligated[c%N]:
                if Z_linear.Q[(c+1)%N][(j-1)%N] > 0:
                    if c == i and (c+1)%N != j and ligated[(j-1)%N]:                Z_cut.backtrack_info[i%N][j%N] +=  [ (Z_linear.Q[(c+1)%N][(j-1)%N], [(Z_linear,(c+1)%N,(j-1)%N)] ) ]
                if Z_linear.Q[(i+1)%N][c%N] > 0:
                    if c != i and (c+1)%N == j and ligated[i%N]:                  Z_cut.backtrack_info[i%N][j%N] +=  [ (Z_linear.Q[(i+1)%N][c%N], [(Z_linear,(i+1)%N,c%N)] ) ]
                if Z_linear.Q[(i+1)%N][c%N] * Z_linear.Q[(c+1)%N][(j-1)%N] > 0:
                    if c != i and (c+1)%N != j and ligated[i%N] and ligated[(j-1)%N]: Z_cut.backtrack_info[i%N][j%N] +=  [ (Z_linear.Q[(i+1)%N][c%N] * Z_linear.Q[(c+1)%N][(j-1)%N], [(Z_linear,(i+1)%N,c%N), (Z_linear,(c+1)%N,(j-1)%N)] ) ]

##################################################################################################
def update_Z_BPq( self, i, j, base_pair_type ):
    '''
    Z_BPq is the partition function for all structures that base pair i and j with base_pair_type
    Relies on previous Z contributions available for subfragments, and Z_cut for this fragment i,j
    '''
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK


    (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
     sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
    offset = ( j - i ) % N

    ( C_eff_for_coax, C_eff_for_BP ) = (C_eff, C_eff ) if allow_strained_3WJ else (C_eff_no_BP_singlet, C_eff_no_coax_singlet )

    (Z_BPq, Kdq)  = ( self.Z_BPq[ base_pair_type ], base_pair_type.Kd )

    if ligated[i%N] and ligated[(j-1)%N]:
        # base pair closes a loop
        #
        #    ~~~~~~
        #   ~      ~
        # i+1      j-1
        #   \       /
        #    i ... j
        #
        contribs.append( (1.0/Kdq ) * ( C_eff_for_BP.Q[(i+1)%N][(j-1)%N] * l * l * l_BP) )

        # base pair forms a stacked pair with previous pair
        #
        #  i+1 ... j-1
        #    |     |
        #    i ... j
        #
        # Note that base pair stacks (C_eff_stack) could also be handled by the MotifType object in the next code block --
        #   only a modest (~10%) slowdown
        for base_pair_type2 in self.possible_base_pair_types[(i+1)%N][(j-1)%N]:
            Z_BPq2 = self.Z_BPq[base_pair_type2]
            contribs.append( (1.0/Kdq ) * self.params.C_eff_stack[base_pair_type][base_pair_type2] * Z_BPq2.Q[(i+1)%N][(j-1)%N] )

    possible_motif_types = self.possible_motif_types[i%N][j%N]
    for motif_type in possible_motif_types[base_pair_type]:
        match_base_pair_type_set = possible_motif_types[base_pair_type][ motif_type ]
        if len(motif_type.strands) == 1: # hairpins (1-way junctions)
            # base pair closes a hairpin
            #            -----
            #           |     |
            #           i ... j
            #          5' bpt  3'
            #
            contribs.append( (1.0/Kdq ) * motif_type.C_eff)
            pass
        elif len(motif_type.strands) == 2: # internal loops (2-way junctions)
            # base pair forms a motif with previous pair
            #
            # Example of 1x1 loop:
            #             bpt0
            #       i_next... j_next
            #           |     |
            #  strand0 i+1   j-1 strand1
            #           |     |
            #           i ... j
            #          5' bpt1 3'
            #
            for (base_pair_type_next, i_next, j_next) in match_base_pair_type_set:
                Z_BPq_next = self.Z_BPq[base_pair_type_next]
                contribs.append( (1.0/Kdq ) * motif_type.C_eff * Z_BPq_next.Q[(i_next)%N][(j_next)%N] )
        # could certainly handle 3WJ in O(N^3) time as well
        # but how about 4WJ? anyway to do without an O(N^4) cost?

    # base pair brings together two strands that were previously disconnected
    #
    #   \       /
    #    i ... j
    #
    contribs.append( (C_std/Kdq) * Z_cut.Q[i%N][j%N] )

    if K_coax > 0.0:
        if ligated[i%N] and ligated[(j-1)%N]:

            # coaxial stack of bp (i,j) and (i+1,k)...  "left stack",  and closes loop on right.
            #      ___
            #     /   \
            #  i+1 ... k - k+1 ~
            #    |              ~
            #    i ... j - j-1 ~
            #
            for k in range( i+2, i+offset-1 ):
                if ligated[k%N]: contribs.append( Z_BP.Q[(i+1)%N][k%N] * C_eff_for_coax.Q[(k+1)%N][(j-1)%N] * l**2 * l_coax * K_coax / Kdq )

            # coaxial stack of bp (i,j) and (k,j-1)...  close loop on left, and "right stack"
            #            ___
            #           /   \
            #  ~ k-1 - k ... j-1
            # ~              |
            #  ~ i+1 - i ... j
            #
            for k in range( i+2, i+offset-1 ):
                if ligated[(k-1)%N]: contribs.append( C_eff_for_coax.Q[(i+1)%N][(k-1)%N] * Z_BP.Q[k%N][(j-1)%N] * l**2 * l_coax * K_coax / Kdq )

        # "left stack" but no loop closed on right (free strands hanging off j end)
        #      ___
        #     /   \
        #  i+1 ... k -
        #    |
        #    i ... j -
        #
        if ligated[i%N]:
            for k in range( i+2, i+offset ):
                contribs.append( Z_BP.Q[(i+1)%N][k%N] * Z_cut.Q[k%N][j%N] * C_std * K_coax / Kdq )

        # "right stack" but no loop closed on left (free strands hanging off i end)
        #       ___
        #      /   \
        #   - k ... j-1
        #           |
        #   - i ... j
        #
        if ligated[(j-1)%N]:
            for k in range( i, i+offset-1 ):
                contribs.append( Z_cut.Q[i%N][k%N] * Z_BP.Q[k%N][(j-1)%N] * C_std * K_coax / Kdq )

    Z_BPq.Q[i%N][j%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
         sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
        offset = ( j - i ) % N
        ( C_eff_for_coax, C_eff_for_BP ) = (C_eff, C_eff ) if allow_strained_3WJ else (C_eff_no_BP_singlet, C_eff_no_coax_singlet )
        (Z_BPq, Kdq)  = ( self.Z_BPq[ base_pair_type ], base_pair_type.Kd )
        if ligated[i%N] and ligated[(j-1)%N]:
            if (1.0/Kdq ) * ( C_eff_for_BP.Q[(i+1)%N][(j-1)%N] * l * l * l_BP) > 0:
                Z_BPq.backtrack_info[i%N][j%N]  +=  [ ((1.0/Kdq ) * ( C_eff_for_BP.Q[(i+1)%N][(j-1)%N] * l * l * l_BP), [(C_eff_for_BP,(i+1)%N,(j-1)%N)] ) ]
            for base_pair_type2 in self.possible_base_pair_types[(i+1)%N][(j-1)%N]:
                Z_BPq2 = self.Z_BPq[base_pair_type2]
                if (1.0/Kdq ) * self.params.C_eff_stack[base_pair_type][base_pair_type2] * Z_BPq2.Q[(i+1)%N][(j-1)%N] > 0:
                    Z_BPq.backtrack_info[i%N][j%N]  +=  [ ((1.0/Kdq ) * self.params.C_eff_stack[base_pair_type][base_pair_type2] * Z_BPq2.Q[(i+1)%N][(j-1)%N], [(Z_BPq2,(i+1)%N,(j-1)%N)] ) ]
        possible_motif_types = self.possible_motif_types[i%N][j%N]
        for motif_type in possible_motif_types[base_pair_type]:
            match_base_pair_type_set = possible_motif_types[base_pair_type][ motif_type ]
            if len(motif_type.strands) == 1: # hairpins (1-way junctions)
                pass
            elif len(motif_type.strands) == 2: # internal loops (2-way junctions)
                for (base_pair_type_next, i_next, j_next) in match_base_pair_type_set:
                    Z_BPq_next = self.Z_BPq[base_pair_type_next]
                    if (1.0/Kdq ) * motif_type.C_eff * Z_BPq_next.Q[(i_next)%N][(j_next)%N] > 0:
                        Z_BPq.backtrack_info[i%N][j%N] +=  [ ((1.0/Kdq ) * motif_type.C_eff * Z_BPq_next.Q[(i_next)%N][(j_next)%N], [(Z_BPq_next,(i_next)%N,(j_next)%N)] ) ]
        if (C_std/Kdq) * Z_cut.Q[i%N][j%N] > 0:
            Z_BPq.backtrack_info[i%N][j%N] +=  [ ((C_std/Kdq) * Z_cut.Q[i%N][j%N], [(Z_cut,i%N,j%N)] ) ]
        if K_coax > 0.0:
            if ligated[i%N] and ligated[(j-1)%N]:
                for k in range( i+2, i+offset-1 ):
                    if Z_BP.Q[(i+1)%N][k%N] * C_eff_for_coax.Q[(k+1)%N][(j-1)%N] * l**2 * l_coax * K_coax / Kdq > 0:
                        if ligated[k%N]: Z_BPq.backtrack_info[i%N][j%N] +=  [ (Z_BP.Q[(i+1)%N][k%N] * C_eff_for_coax.Q[(k+1)%N][(j-1)%N] * l**2 * l_coax * K_coax / Kdq, [(Z_BP,(i+1)%N,k%N), (C_eff_for_coax,(k+1)%N,(j-1)%N)] ) ]
                for k in range( i+2, i+offset-1 ):
                    if C_eff_for_coax.Q[(i+1)%N][(k-1)%N] * Z_BP.Q[k%N][(j-1)%N] * l**2 * l_coax * K_coax / Kdq > 0:
                        if ligated[(k-1)%N]: Z_BPq.backtrack_info[i%N][j%N] +=  [ (C_eff_for_coax.Q[(i+1)%N][(k-1)%N] * Z_BP.Q[k%N][(j-1)%N] * l**2 * l_coax * K_coax / Kdq, [(C_eff_for_coax,(i+1)%N,(k-1)%N), (Z_BP,k%N,(j-1)%N)] ) ]
            if ligated[i%N]:
                for k in range( i+2, i+offset ):
                    if Z_BP.Q[(i+1)%N][k%N] * Z_cut.Q[k%N][j%N] * C_std * K_coax / Kdq > 0:
                        Z_BPq.backtrack_info[i%N][j%N] +=  [ (Z_BP.Q[(i+1)%N][k%N] * Z_cut.Q[k%N][j%N] * C_std * K_coax / Kdq, [(Z_BP,(i+1)%N,k%N), (Z_cut,k%N,j%N)] ) ]
            if ligated[(j-1)%N]:
                for k in range( i, i+offset-1 ):
                    if Z_cut.Q[i%N][k%N] * Z_BP.Q[k%N][(j-1)%N] * C_std * K_coax / Kdq > 0:
                        Z_BPq.backtrack_info[i%N][j%N] +=  [ (Z_cut.Q[i%N][k%N] * Z_BP.Q[k%N][(j-1)%N] * C_std * K_coax / Kdq, [(Z_cut,i%N,k%N), (Z_BP,k%N,(j-1)%N)] ) ]

##################################################################################################
def update_Z_BP( self, i, j ):
    '''
    Z_BP is the partition function for all structures that base pair i and j.
    All the Z_BPq (partition functions for each base pair type) must have been
    filled in already for i,j.
    '''
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK

    (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
     sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )

    for base_pair_type in self.possible_base_pair_types[i%N][j%N]:
        Z_BPq = self.Z_BPq[base_pair_type]
        Z_BPq.update( self, i, j )
        contribs.append( Z_BPq.Q[i%N][j%N] )

    Z_BP.Q[i%N][j%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
         sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
        for base_pair_type in self.possible_base_pair_types[i%N][j%N]:
            Z_BPq = self.Z_BPq[base_pair_type]
            Z_BPq.update( self, i, j )
            if Z_BPq.Q[i%N][j%N] > 0:
                Z_BP.backtrack_info[i%N][j%N]  +=  [ (Z_BPq.Q[i%N][j%N], [(Z_BPq,i%N,j%N)] ) ]

##################################################################################################
def update_Z_coax( self, i, j ):
    '''
    Z_coax(i,j) is the partition function for all structures that form coaxial stacks between (i,k) and (k+1,j) for some k
    '''
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK

    (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
     sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
    offset = ( j - i ) % N

    if (offset == N-1) and ligated[j%N]: return

    #  all structures that form coaxial stacks between (i,k) and (k+1,j) for some k
    #
    #       -- k - k+1 -
    #      /   :    :   \
    #      \   :    :   /
    #       -- i    j --
    #
    if K_coax > 0:
        for k in range( i+1, i+offset-1 ):
            if ligated[k%N]:
                if Z_BP.val(i,k) == 0.0: continue
                if Z_BP.val(k+1,j) == 0.0: continue
                contribs.append( Z_BP.Q[i%N][k%N] * Z_BP.Q[(k+1)%N][j%N] * K_coax )

    Z_coax.Q[i%N][j%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
         sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
        offset = ( j - i ) % N
        if (offset == N-1) and ligated[j%N]: return
        if K_coax > 0:
            for k in range( i+1, i+offset-1 ):
                if ligated[k%N]:
                    if Z_BP.val(i,k) == 0.0: continue
                    if Z_BP.val(k+1,j) == 0.0: continue
                    if Z_BP.Q[i%N][k%N] * Z_BP.Q[(k+1)%N][j%N] * K_coax > 0:
                        Z_coax.backtrack_info[i%N][j%N]  +=  [ (Z_BP.Q[i%N][k%N] * Z_BP.Q[(k+1)%N][j%N] * K_coax, [(Z_BP,i%N,k%N), (Z_BP,(k+1)%N,j%N)] ) ]

##################################################################################################
def update_C_eff_basic( self, i, j ):
    '''
    C_eff tracks the effective molarity of a loop starting at i and ending at j
    Assumes a model where each additional element multiplicatively reduces the effective molarity, by
      the variables l, l_BP,  K_coax, etc.
    Relies on previous Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear available for subfragments.
    Relies on Z_BP being already filled out for i,j
    TODO: In near future, will include possibility of multiple C_eff terms, which combined together will
      allow for free energy costs of loop closure to scale approximately log-linearly rather than
      linearly with loop size.
    '''
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK

    offset = ( j - i ) % self.N

    (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
     sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )


    # j is not base paired or coaxially stacked: Extension by one residue from j-1 to j.
    #
    #    i ~~~~~~ j-1 - j
    #
    allow_loop_extension = not ( self.in_forced_base_pair and self.in_forced_base_pair[j%N] )
    if ligated[(j-1)%N] and allow_loop_extension: contribs.append( C_eff.Q[i%N][(j-1)%N] * l )

    exclude_strained_3WJ = (not allow_strained_3WJ) and (offset == N-1) and ligated[j%N]

    # j is base paired, and its partner is k > i. (look below for case with i and j base paired)
    #                 ___
    #                /   \
    #    i ~~~~k-1 - k...j
    #
    C_eff_for_BP = C_eff_no_coax_singlet if exclude_strained_3WJ else C_eff
    for k in range( i+1, i+offset):
        if ligated[(k-1)%N]: contribs.append( C_eff_for_BP.Q[i%N][(k-1)%N] * l * Z_BP.Q[k%N][j%N] * l_BP )

    if K_coax > 0:
        # j is coax-stacked, and its partner is k > i.  (look below for case with i and j coaxially stacked)
        #               _______
        #              / :   : \
        #              \ :   : /
        #    i ~~~~k-1 - k   j
        #
        C_eff_for_coax = C_eff_no_BP_singlet if exclude_strained_3WJ else C_eff
        for k in range( i+1, i+offset):
            if ligated[(k-1)%N]: contribs.append( C_eff_for_coax.Q[i%N][(k-1)%N] * Z_coax.Q[k%N][j%N] * l * l_coax )

    C_eff_basic.Q[i%N][j%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        offset = ( j - i ) % self.N
        (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
         sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
        allow_loop_extension = not ( self.in_forced_base_pair and self.in_forced_base_pair[j%N] )
        if C_eff.Q[i%N][(j-1)%N] * l > 0:
            if ligated[(j-1)%N] and allow_loop_extension: C_eff_basic.backtrack_info[i%N][j%N] +=  [ (C_eff.Q[i%N][(j-1)%N] * l, [(C_eff,i%N,(j-1)%N)] ) ]
        exclude_strained_3WJ = (not allow_strained_3WJ) and (offset == N-1) and ligated[j%N]
        C_eff_for_BP = C_eff_no_coax_singlet if exclude_strained_3WJ else C_eff
        for k in range( i+1, i+offset):
            if C_eff_for_BP.Q[i%N][(k-1)%N] * l * Z_BP.Q[k%N][j%N] * l_BP > 0:
                if ligated[(k-1)%N]: C_eff_basic.backtrack_info[i%N][j%N] +=  [ (C_eff_for_BP.Q[i%N][(k-1)%N] * l * Z_BP.Q[k%N][j%N] * l_BP, [(C_eff_for_BP,i%N,(k-1)%N), (Z_BP,k%N,j%N)] ) ]
        if K_coax > 0:
            C_eff_for_coax = C_eff_no_BP_singlet if exclude_strained_3WJ else C_eff
            for k in range( i+1, i+offset):
                if C_eff_for_coax.Q[i%N][(k-1)%N] * Z_coax.Q[k%N][j%N] * l * l_coax > 0:
                    if ligated[(k-1)%N]: C_eff_basic.backtrack_info[i%N][j%N] +=  [ (C_eff_for_coax.Q[i%N][(k-1)%N] * Z_coax.Q[k%N][j%N] * l * l_coax, [(C_eff_for_coax,i%N,(k-1)%N), (Z_coax,k%N,j%N)] ) ]

##################################################################################################
def update_C_eff_no_coax_singlet( self, i, j ):
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK

    (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
     sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )

    # some helper arrays that prevent closure of any 3WJ with a single coaxial stack and single helix with not intervening loop nucleotides
    contribs.append( C_eff_basic.Q[i%N][j%N] )
    contribs.append( C_init * Z_BP.Q[i%N][j%N] * l_BP )

    C_eff_no_coax_singlet.Q[i%N][j%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
         sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
        if C_eff_basic.Q[i%N][j%N] > 0:
            C_eff_no_coax_singlet.backtrack_info[i%N][j%N] +=  [ (C_eff_basic.Q[i%N][j%N], [(C_eff_basic,i%N,j%N)] ) ]
        if C_init * Z_BP.Q[i%N][j%N] * l_BP > 0:
            C_eff_no_coax_singlet.backtrack_info[i%N][j%N] +=  [ (C_init * Z_BP.Q[i%N][j%N] * l_BP, [(Z_BP,i%N,j%N)] ) ]

##################################################################################################
def update_C_eff_no_BP_singlet( self, i, j ):
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK

    (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
     sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )

    if K_coax > 0.0:
        contribs.append( C_eff_basic.Q[i%N][j%N] )
        contribs.append( C_init * Z_coax.Q[i%N][j%N] * l_coax )

    C_eff_no_BP_singlet.Q[i%N][j%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
         sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
        if K_coax > 0.0:
            if C_eff_basic.Q[i%N][j%N] > 0:
                C_eff_no_BP_singlet.backtrack_info[i%N][j%N] +=  [ (C_eff_basic.Q[i%N][j%N], [(C_eff_basic,i%N,j%N)] ) ]
            if C_init * Z_coax.Q[i%N][j%N] * l_coax > 0:
                C_eff_no_BP_singlet.backtrack_info[i%N][j%N] +=  [ (C_init * Z_coax.Q[i%N][j%N] * l_coax, [(Z_coax,i%N,j%N)] ) ]

##################################################################################################
def update_C_eff( self, i, j ):
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK

    (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
     sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )

    contribs.append( C_eff_basic.Q[i%N][j%N] )

    # j is base paired, and its partner is i
    #      ___
    #     /   \
    #  i+1 ... j-1
    #    |     |
    #    i ... j
    #
    contribs.append( C_init * Z_BP.Q[i%N][j%N] * l_BP )

    if K_coax > 0.0:
        # j is coax-stacked, and its partner is i.
        #       ------------
        #      /   :    :   \
        #      \   :    :   /
        #       -- i    j --
        #
        contribs.append( C_init * Z_coax.Q[i%N][j%N] * l_coax )

    C_eff.Q[i%N][j%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
         sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
        if C_eff_basic.Q[i%N][j%N] > 0:
            C_eff.backtrack_info[i%N][j%N] +=  [ (C_eff_basic.Q[i%N][j%N], [(C_eff_basic,i%N,j%N)] ) ]
        if C_init * Z_BP.Q[i%N][j%N] * l_BP > 0:
            C_eff.backtrack_info[i%N][j%N] +=  [ (C_init * Z_BP.Q[i%N][j%N] * l_BP, [(Z_BP,i%N,j%N)] ) ]
        if K_coax > 0.0:
            if C_init * Z_coax.Q[i%N][j%N] * l_coax > 0:
                C_eff.backtrack_info[i%N][j%N] +=  [ (C_init * Z_coax.Q[i%N][j%N] * l_coax, [(Z_coax,i%N,j%N)] ) ]

##################################################################################################
def update_Z_linear( self, i, j ):
    '''
    Z_linear tracks the total partition function from i to j, assuming all intervening residues are covalently connected (or base-paired).
    Relies on previous Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear available for subfragments.
    Relies on Z_BP being already filled out for i,j
    '''
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK

    offset = ( j - i ) % self.N

    (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
     sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )

    # j is not base paired: Extension by one residue from j-1 to j.
    #
    #    i ~~~~~~ j-1 - j
    #
    allow_loop_extension = ( not self.in_forced_base_pair ) or ( not self.in_forced_base_pair[j%N] )
    if ligated[(j-1)%N] and allow_loop_extension: contribs.append( Z_linear.Q[i%N][(j-1)%N] )

    # j is base paired, and its partner is i
    #     ___
    #    /   \
    #    i...j
    #
    contribs.append( Z_BP.Q[i%N][j%N] )

    # j is base paired, and its partner is k > i
    #                 ___
    #                /   \
    #    i ~~~~k-1 - k...j
    #
    for k in range( i+1, i+offset):
        if ligated[(k-1)%N]: contribs.append( Z_linear.Q[i%N][(k-1)%N] * Z_BP.Q[k%N][j%N] )

    if K_coax > 0.0:
        # j is coax-stacked, and its partner is i.
        #       ------------
        #      /   :    :   \
        #      \   :    :   /
        #       -- i    j --
        #
        contribs.append( Z_coax.Q[i%N][j%N] )

        # j is coax-stacked, and its partner is k > i.
        #
        #               _______
        #              / :   : \
        #              \ :   : /
        #    i ~~~~k-1 - k   j
        #
        for k in range( i+1, i+offset):
            if ligated[(k-1)%N]: contribs.append( Z_linear.Q[i%N][(k-1)%N] * Z_coax.Q[k%N][j%N] )


    Z_linear.Q[i%N][j%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        offset = ( j - i ) % self.N
        (C_init, l, l_BP,  K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
         sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
        allow_loop_extension = ( not self.in_forced_base_pair ) or ( not self.in_forced_base_pair[j%N] )
        if Z_linear.Q[i%N][(j-1)%N] > 0:
            if ligated[(j-1)%N] and allow_loop_extension: Z_linear.backtrack_info[i%N][j%N] +=  [ (Z_linear.Q[i%N][(j-1)%N], [(Z_linear,i%N,(j-1)%N)] ) ]
        if Z_BP.Q[i%N][j%N] > 0:
            Z_linear.backtrack_info[i%N][j%N] +=  [ (Z_BP.Q[i%N][j%N], [(Z_BP,i%N,j%N)] ) ]
        for k in range( i+1, i+offset):
            if Z_linear.Q[i%N][(k-1)%N] * Z_BP.Q[k%N][j%N] > 0:
                if ligated[(k-1)%N]: Z_linear.backtrack_info[i%N][j%N] +=  [ (Z_linear.Q[i%N][(k-1)%N] * Z_BP.Q[k%N][j%N], [(Z_linear,i%N,(k-1)%N), (Z_BP,k%N,j%N)] ) ]
        if K_coax > 0.0:
            if Z_coax.Q[i%N][j%N] > 0:
                Z_linear.backtrack_info[i%N][j%N] +=  [ (Z_coax.Q[i%N][j%N], [(Z_coax,i%N,j%N)] ) ]
            for k in range( i+1, i+offset):
                if Z_linear.Q[i%N][(k-1)%N] * Z_coax.Q[k%N][j%N] > 0:
                    if ligated[(k-1)%N]: Z_linear.backtrack_info[i%N][j%N] +=  [ (Z_linear.Q[i%N][(k-1)%N] * Z_coax.Q[k%N][j%N], [(Z_linear,i%N,(k-1)%N), (Z_coax,k%N,j%N)] ) ]

##################################################################################################
def update_Z_final( self, i ):
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK

    # Z_final is total partition function, and is computed at end of filling dynamic programming arrays
    # Get the answer (in N ways!) --> so final output is actually Z_final(i), an array.
    # Equality of the array is tested in run_cross_checks()
    (C_init, l, l_BP, K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
     sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )

    Z_final = self.Z_final
    if not ligated[((i - 1))%N]:
        #
        #      i ------- i-1
        #
        #     or equivalently
        #        ________
        #       /        \
        #       \        /
        #        i-1    i
        #
        contribs.append( Z_linear.Q[i%N][(i-1)%N] )
    else:
        # Need to 'ligate' across i-1 to i
        # Scaling Z_final by Kd_lig/C_std to match previous literature conventions

        # Need to remove Z_coax contribution from C_eff, since its covered by C_eff_stacked_pair below.
        contribs.append( C_eff_no_coax_singlet.Q[i%N][(i-1)%N] * l / C_std )

        #any split segments, combined independently
        #
        #   c+1 --- i-1 - i --- c
        #               *
        for c in range( i, i + N - 1):
            if not ligated[c%N]: contribs.append( Z_linear.Q[i%N][c%N] * Z_linear.Q[(c+1)%N][(i-1)%N] )

        for j in range( i+1, (i + N - 1) ):
            # base pair forms a stacked pair with previous pair
            #
            #              <--3'
            #         - j+1 - j -
            #  bpt2 |    :    :    ^ bpt1
            #       V    :    :    |
            #         - i-1 - i -
            #               * 5'-->
            #
            if ligated[j%N]:
                if Z_BP.val(i,j) > 0.0 and Z_BP.val(j+1,i-1) > 0.0:
                    for base_pair_type in self.params.base_pair_types:
                        if self.Z_BPq[base_pair_type].val(i,j) == 0.0: continue
                        for base_pair_type2 in self.params.base_pair_types:
                            if self.Z_BPq[base_pair_type2].val(j+1,i-1) == 0.0: continue
                            Z_BPq1 = self.Z_BPq[base_pair_type]
                            Z_BPq2 = self.Z_BPq[base_pair_type2]
                            # could also use self.params.C_eff_stack[base_pair_type.flipped][base_pair_type2]  -- should be the same as below.
                            contribs.append( self.params.C_eff_stack[base_pair_type2.flipped][base_pair_type] * Z_BPq2.Q[(j+1)%N][(i-1)%N] * Z_BPq1.Q[i%N][j%N] )

            # ligation allows an internal loop motif to form across i-1 to i
            #
            #           <--
            #        - j_next ----------- j -
            # bpt0 |      :               :   ^ bpt1
            #      v      :               :   |
            #        - k_next - i-1 - i - k -
            #                       *  -->
            #
            #   where k = i, i+1, ... (i + strand_length-2),
            #      i.e., ligation is inside last strand of motif
            #
            for k in range( i, i + self.max_motif_strand_length - 1 ):
                for base_pair_type in self.possible_base_pair_types[j%N][k%N]:
                    possible_motif_types = self.possible_motif_types[j%N][k%N]
                    for motif_type in possible_motif_types[base_pair_type]:
                        if len( motif_type.strands) != 2: continue
                        if ( (k - i + 1) >= len( motif_type.strands[-1] ) ): continue
                        match_base_pair_type_set = possible_motif_types[base_pair_type][motif_type]
                        base_pair_type1 = base_pair_type.flipped
                        for (base_pair_type0,j_next,k_next) in match_base_pair_type_set:
                            Z_BPq0 = self.Z_BPq[base_pair_type0]
                            Z_BPq1 = self.Z_BPq[base_pair_type1]
                            contribs.append( motif_type.C_eff * Z_BPq0.Q[(j_next)%N][(k_next)%N] * Z_BPq1.Q[k%N][j%N] )


        # ligation allows a hairpin to close across i-1 to i
        #
        #        <--3'
        #       ------- j -
        #      |        :  ^ bpt1
        #      |        :  |
        #     i-1 - i - k -
        #         * 5'-->
        #   where k = i, i+1, ... (i + strand_length-2),
        #      i.e., ligation is inside hairpin loop
        #
        for motif_type in self.params.motif_types:
            if len( motif_type.strands) != 1: continue
            L = len( motif_type.strands[0] ) # for a tetraloop this is 1+4+1 = 6
            for k in range( i, i+L-1 ):
                j = ( k - L + 1 ) % N
                for base_pair_type in self.possible_base_pair_types[j%N][k%N]:
                    # N.B. could be made a little faster if we cache which hairpins are allowed at each j,k and for those, keep base pairs.
                    possible_motif_types = self.possible_motif_types[j%N][k%N]
                    if not motif_type in possible_motif_types[ base_pair_type ]: continue
                    Z_BPq1 = self.Z_BPq[base_pair_type.flipped]
                    contribs.append( motif_type.C_eff * Z_BPq1.Q[k%N][j%N] )

        if K_coax > 0:
            C_eff_for_coax = C_eff if allow_strained_3WJ else C_eff_no_BP_singlet

            # New co-axial stack might form across ligation junction
            for j in range( i + 1, i + N - 2):
                # If the two coaxially stacked base pairs are connected by a loop.
                #
                #       ~~~~
                #   -- k    j --
                #  /   :    :   \
                #  \   :    :   /
                #   - i-1 - i --
                #         *
                for k in range( j + 2, i + N - 1):
                    if not ligated[j%N]: continue
                    if not ligated[(k-1)%N]: continue
                    if Z_BP.val(i,j) == 0: continue
                    if Z_BP.val(k,i-1) == 0: continue
                    contribs.append( Z_BP.Q[i%N][j%N] * C_eff_for_coax.Q[(j+1)%N][(k-1)%N] * Z_BP.Q[k%N][(i-1)%N] * l * l * l_coax * K_coax )

                # If the two stacked base pairs are in split segments
                #
                #      \    /
                #   -- k    j --
                #  /   :    :   \
                #  \   :    :   /
                #   - i-1 - i --
                #         *
                for k in range( j + 1, i + N - 1):
                    if Z_BP.val(i,j) == 0: continue
                    if Z_BP.val(k,i-1) == 0: continue
                    if (k-j)%N == 1 and ligated[j%N]: continue
                    contribs.append( Z_BP.Q[i%N][j%N] * Z_cut.Q[j%N][k%N] * Z_BP.Q[k%N][(i-1)%N] * K_coax )


    Z_final.Q[i%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        (C_init, l, l_BP, K_coax, l_coax, C_std, min_loop_length, allow_strained_3WJ, N, \
         sequence, ligated, all_ligated, Z_BP, C_eff_basic, C_eff_no_BP_singlet, C_eff_no_coax_singlet, C_eff, Z_linear, Z_cut, Z_coax ) = unpack_variables( self )
        Z_final = self.Z_final
        if not ligated[((i - 1))%N]:
            if Z_linear.Q[i%N][(i-1)%N] > 0:
                Z_final.backtrack_info[i%N] +=  [ (Z_linear.Q[i%N][(i-1)%N], [(Z_linear,i%N,(i-1)%N)] ) ]
        else:
            if C_eff_no_coax_singlet.Q[i%N][(i-1)%N] * l / C_std > 0:
                Z_final.backtrack_info[i%N] +=  [ (C_eff_no_coax_singlet.Q[i%N][(i-1)%N] * l / C_std, [(C_eff_no_coax_singlet,i%N,(i-1)%N)] ) ]
            for c in range( i, i + N - 1):
                if Z_linear.Q[i%N][c%N] * Z_linear.Q[(c+1)%N][(i-1)%N] > 0:
                    if not ligated[c%N]: Z_final.backtrack_info[i%N] +=  [ (Z_linear.Q[i%N][c%N] * Z_linear.Q[(c+1)%N][(i-1)%N], [(Z_linear,i%N,c%N), (Z_linear,(c+1)%N,(i-1)%N)] ) ]
            for j in range( i+1, (i + N - 1) ):
                if ligated[j%N]:
                    if Z_BP.val(i,j) > 0.0 and Z_BP.val(j+1,i-1) > 0.0:
                        for base_pair_type in self.params.base_pair_types:
                            if self.Z_BPq[base_pair_type].val(i,j) == 0.0: continue
                            for base_pair_type2 in self.params.base_pair_types:
                                if self.Z_BPq[base_pair_type2].val(j+1,i-1) == 0.0: continue
                                Z_BPq1 = self.Z_BPq[base_pair_type]
                                Z_BPq2 = self.Z_BPq[base_pair_type2]
                                if self.params.C_eff_stack[base_pair_type2.flipped][base_pair_type] * Z_BPq2.Q[(j+1)%N][(i-1)%N] * Z_BPq1.Q[i%N][j%N] > 0:
                                    Z_final.backtrack_info[i%N] +=  [ (self.params.C_eff_stack[base_pair_type2.flipped][base_pair_type] * Z_BPq2.Q[(j+1)%N][(i-1)%N] * Z_BPq1.Q[i%N][j%N], [(Z_BPq2,(j+1)%N,(i-1)%N), (Z_BPq1,i%N,j%N)] ) ]
                for k in range( i, i + self.max_motif_strand_length - 1 ):
                    for base_pair_type in self.possible_base_pair_types[j%N][k%N]:
                        possible_motif_types = self.possible_motif_types[j%N][k%N]
                        for motif_type in possible_motif_types[base_pair_type]:
                            if len( motif_type.strands) != 2: continue
                            if ( (k - i + 1) >= len( motif_type.strands[-1] ) ): continue
                            match_base_pair_type_set = possible_motif_types[base_pair_type][motif_type]
                            base_pair_type1 = base_pair_type.flipped
                            for (base_pair_type0,j_next,k_next) in match_base_pair_type_set:
                                Z_BPq0 = self.Z_BPq[base_pair_type0]
                                Z_BPq1 = self.Z_BPq[base_pair_type1]
                                if motif_type.C_eff * Z_BPq0.Q[(j_next)%N][(k_next)%N] * Z_BPq1.Q[k%N][j%N] > 0:
                                    Z_final.backtrack_info[i%N]  +=  [ (motif_type.C_eff * Z_BPq0.Q[(j_next)%N][(k_next)%N] * Z_BPq1.Q[k%N][j%N], [(Z_BPq0,(j_next)%N,(k_next)%N), (Z_BPq1,k%N,j%N)] ) ]
            for motif_type in self.params.motif_types:
                if len( motif_type.strands) != 1: continue
                L = len( motif_type.strands[0] ) # for a tetraloop this is 1+4+1 = 6
                for k in range( i, i+L-1 ):
                    j = ( k - L + 1 ) % N
                    for base_pair_type in self.possible_base_pair_types[j%N][k%N]:
                        possible_motif_types = self.possible_motif_types[j%N][k%N]
                        if not motif_type in possible_motif_types[ base_pair_type ]: continue
                        Z_BPq1 = self.Z_BPq[base_pair_type.flipped]
                        if motif_type.C_eff * Z_BPq1.Q[k%N][j%N] > 0:
                            Z_final.backtrack_info[i%N]  +=  [ (motif_type.C_eff * Z_BPq1.Q[k%N][j%N], [(Z_BPq1,k%N,j%N)] ) ]
            if K_coax > 0:
                C_eff_for_coax = C_eff if allow_strained_3WJ else C_eff_no_BP_singlet
                for j in range( i + 1, i + N - 2):
                    for k in range( j + 2, i + N - 1):
                        if not ligated[j%N]: continue
                        if not ligated[(k-1)%N]: continue
                        if Z_BP.val(i,j) == 0: continue
                        if Z_BP.val(k,i-1) == 0: continue
                        if Z_BP.Q[i%N][j%N] * C_eff_for_coax.Q[(j+1)%N][(k-1)%N] * Z_BP.Q[k%N][(i-1)%N] * l * l * l_coax * K_coax > 0:
                            Z_final.backtrack_info[i%N] +=  [ (Z_BP.Q[i%N][j%N] * C_eff_for_coax.Q[(j+1)%N][(k-1)%N] * Z_BP.Q[k%N][(i-1)%N] * l * l * l_coax * K_coax, [(Z_BP,i%N,j%N), (C_eff_for_coax,(j+1)%N,(k-1)%N), (Z_BP,k%N,(i-1)%N)] ) ]
                    for k in range( j + 1, i + N - 1):
                        if Z_BP.val(i,j) == 0: continue
                        if Z_BP.val(k,i-1) == 0: continue
                        if (k-j)%N == 1 and ligated[j%N]: continue
                        if Z_BP.Q[i%N][j%N] * Z_cut.Q[j%N][k%N] * Z_BP.Q[k%N][(i-1)%N] * K_coax > 0:
                            Z_final.backtrack_info[i%N] +=  [ (Z_BP.Q[i%N][j%N] * Z_cut.Q[j%N][k%N] * Z_BP.Q[k%N][(i-1)%N] * K_coax, [(Z_BP,i%N,j%N), (Z_cut,j%N,k%N), (Z_BP,k%N,(i-1)%N)] ) ]

##################################################################################################
def unpack_variables( self ):
    '''
    This helper function just lets me write out equations without
    using "self" which obscures connection to my handwritten equations
    In C++, will just use convention of object variables like N_, sequence_.
    '''
    contribs = [] # AUTOGENERATED SUM_AT_END BLOCK

    return self.params.get_variables() + \
           ( self.N, self.sequence, self.ligated, self.all_ligated,  \
             self.Z_BP,self.C_eff_basic,self.C_eff_no_BP_singlet,self.C_eff_no_coax_singlet,self.C_eff,\
             self.Z_linear,self.Z_cut,self.Z_coax )
    Z_final.Q[i%N] = sum( contribs )

    if self.options.calc_backtrack_info: # AUTOGENERATED CONTRIBS BLOCK
        return self.params.get_variables() + \
               ( self.N, self.sequence, self.ligated, self.all_ligated,  \
                 self.Z_BP,self.C_eff_basic,self.C_eff_no_BP_singlet,self.C_eff_no_coax_singlet,self.C_eff,\
                 self.Z_linear,self.Z_cut,self.Z_coax )

